<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title></title>
</head>
<body>
<script>

    /*
    * a reference value is an instance of reference type. in JS, reference type are constructors used to group data and
    * functionality together and are often incorrectly called classes. Reference types are also sometimes called object definitions.
    * they describe the properties and methods that objects should have.
    *
    * objects are considered to be instances of a particular reference type. new objects are created by using the new operator
    * followed by a constructor.
    *
    * a constructor is similar as the function whose purpose is to create a new object.
    * */

    /*
    * object type --
    * there are two ways to explicitly create an instance of Object. The first one is to use the new operator with the Object
    * constructor.
    * */
    var person = new Object();
    person.name = "Leo";
    person.age = 29;

    /*
    * the other one is to use object literal notation, which is a shorthand of form of object definition designed to simplify creating an object with
    * numerous properties. we recommend this method. object literal has become a preferred way of passing a large number of optional arguments to a function
    * */

    var person = {
        name: "rick",
        age: 30
    };

    function displayInfo(args) {
        var output = "";

        if (typeof args.name == "string") {
            output += "name: " + args.name + "\n";
        }

        if (typeof args.age == "number") {
            output += "age: " + args.age + "\n";
        }
        console.log(output);
    }

    displayInfo({
        name: "rick",
        age: 20
    });
    displayInfo({
        name: "leo"
    });

    // dot notation and bracket notation

    console.log(person.name);
    console.log(person["name"]);

    /*
    * we can use bracket notation when the property name contains characters that would be either a syntax error or a keyword
    * */


    /*
    * The Array Type --
    * JS arrays are ordered lists of data, they can hold any type of data in each slot, this means that its possible to create an array that has a string in the first
    * position, a number in the second, and an object in the third, and so on. arrays can be created in two basic ways, the first is to use the Array constructor
    * */

    var colors = new Array();
    var colors = new Array("red", "blue", "green");
    console.log(colors); // [red, blue, green]
    var colors = new Array(3);
    var colors = Array(4);
    var names = Array("rick");

    // the second way to create an array is by using array literal notation.
    var colors = ["green", 'red', 'yellow'];
    var names = [];
    var values = [1,2,];
    var option = [,,,,];

    // the length property is writable and readable
    var colors = [1, 2, 4];
    colors.length = 2;
    console.log(colors[2]); // undefined

    // the length property can also be helpful in adding items to the end of an array.
    colors[colors.length] = "black";
    console.log(colors); // 1 2 black


    /*
    * detecting array
    * */
//    if (value instanceof Array) {
//        // do something on the array
//    }
//
//    if (Array.isArray(value)) {
//        // do something on the array
//    }

    /*
    * conversion method --
    * all objects have toLocaleString(), toString(), valueOf(). toString() and valueOf() methods return the same value when called on an array
    * */
    var colors = ["red", 'blue', 'green'];
    console.log(colors.toString());
    console.log(typeof (colors.toString())); // string
    console.log(colors.valueOf());
    console.log(typeof (colors.valueOf())); // object
    console.log(colors);
    console.log(typeof colors);  // object

    var person1 = {
        toLocaleString: function () {
            return "localeLeo";
        },
        toString: function () {
            return "leo";
        }
    };
    var person2 = {
        toLocaleString: function () {
            return "localeRick";
        },
        toString: function () {
            return "rick";
        }
    };
    var people = [person1, person2];
    console.log(people); // array
    console.log(people.toString());  // leo rick
    console.log(people.toLocaleString()); // localeLeo, localeRick

    var colors = ["red", "yello", "blue"];
    console.log(colors.join("|")); // red|yellow|blue
    console.log(colors.join(".")); // red.yellow.blue

    // if an item in array is null or undefined, it is represented by an empty string in the result of join(), toLocaleString(), toString(), valueOf()

    /*
    * stack method
    * a stack is reference to as last-in-first-out structure, meaning that the most recently added item is the first one removed. the insertion and removal
    * of items in  a stack occur at only one point: the top of the stack.
    *
    * the push() method accepts any number of arguments and adds them to the end of the array, returning the array's new length.
    * the pop() method removes the last item in the array, decrements the array's length, and return that item.
    * */
    var colors = new Array();
    var count = colors.push("red", "green");
    console.log(count);

    count = colors.push("black");
    console.log(count);

    var item = colors.pop();
    console.log(item);
    console.log(colors);
    console.log(colors.length); // red green

    /*
    * queue methods --
    * queue restrict access in a first-in-first-out data structure.
    * shift() method retrieve the first item in the array, which removes the first item in the array and returns it.
    * unshift() method adds any number of items to the front of an array and returns the new array.
    * */

    var colors = new Array();
    var count = colors.push("red", "green");
    console.log(count);

    var count = colors.push("yellow");
    console.log(count);

    var item = colors.shift();
    console.log(item); // red
    console.log(colors.length); // 2

    var colors = new Array();
    var count = colors.unshift("red", "green");
    console.log(count);

    count = colors.unshift("white");
    var item = colors.pop();
    console.log(item); // green


    /*
    * reordering method
    *
    * reverse() and sort()
    *
    *
    * */
    var values = [1,2,3,4,5];
    values.reverse();
    console.log(values); // 5 4 3 2 1

    var values = [0, 1,5,10,15];
    values.sort();
    console.log(values);

    function compare(val1, val2) {
        if (val1 < val2) {
            return -1;
        } else if (val1 > val2) {
            return 1;
        } else {
            return 0;
        }
    }

    var values = [0, 1, 5, 10, 15];
    values.sort(compare);
    console.log(values); // 0 1 5 10 15

    function compare1(val1, val2) {
        if (val1 < val2) {
            return 1;
        } else if (val1 > val2) {
            return -1;
        } else {
            return 0;
        }
    }
    values.sort(compare1);
    console.log(values); // 15 10 5 1 0

    // a much simpler version of the comparison function can be used with numeric types
    function compare2(val1, val2) {
        return val2 - val1;
    }


    /*
    * manipulation method --
    * */

    var colors = ["red", "green", "blue"];
    var colors2 = colors.concat("yellow", ["black", "brown"]);
    console.log(colors); // red green blue
    console.log(colors2); // red green blue yellow black brown


    //slice(arg1, arg2), may accept
    var colors3 = colors2.slice(1);  // ["green", "blue", "yellow", "black", "brown"]
    var colors4 = colors2.slice(1, 4); // green, blue, yellow
    console.log(colors3);
    console.log(colors4);

    // splice(),
    /*
    * deletion -- any number of items can be deleted from the array by specifying just two arguments: the position of the first item to delete and the number of items
    * to delete.
    *
    * insertion -- three arguments, the starting position, the numbers of items to be deleted and the items to insert.
    *
    * replacement -- items can be inserted into a specific position while simultaneously deleting items,
    * */

    var colors = ["red", "green", "blue"];
    var removed = colors.splice(0, 1);
    console.log(colors); // green, blue
    console.log(removed); // red

    removed = colors.splice(1, 0, "yellow", "orange");
    console.log(colors); // green, yellow, orange, blue
    console.log(removed); // []

    removed = colors.splice(1, 1, "red", "purple");
    console.log(colors); // green, red, purple, orange, blue
    console.log(removed); // yellow


    /*
    * Location Method --
    * indexOf() and lastIndexOf() , which accept two arguments: the item to look for and an optional index from which to start looking.
    * indexOf() start from the index 0, and lastIndexOf() start from the last item.
    * */

    var numbers = [1 ,2, 3, 4, 5, 4, 3, 2, 1];

    console.log(numbers.indexOf(4)); // 3
    console.log(numbers.lastIndexOf(4)); // 5

    console.log(numbers.indexOf(4, 4)); // 5
    console.log(numbers.lastIndexOf(4, 4)); // 3

    var person = {name: "rick"};
    var people = [{name: "rick"}];

    var morePeople = [person];
    console.log(people.indexOf(person)); // -1
    console.log(morePeople.indexOf(person)); // 0

    /*
    * iterative method --
    *
    * every() -- runs the given function on every item in the array and returns true if the function returns true for every item.
    *
    * filter() -- runs the given function on every item in the array and returns an array of all items for which the function returns true.
    *
    * forEach() -- runs the given function on every item in the array. this method has no return value.
    *
    * map() -- runs the given function on every item in the array and returns the result of each function call in an array.
    *
    * some() -- runs the given function on every item in the array and returns true if the function returns true for any one item.
    * */

    var numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];

    var everyResult = numbers.every(function (item, index, array) {
        return (item > 2);
    });
    console.log(everyResult); // false

    var someResult = numbers.some(function (item, index, array) {
        return (item > 2);
    });
    console.log(someResult); // true

    var filterResult = numbers.filter(function (item, index, array) {
        return (item > 2);
    });
    console.log(filterResult); // [3, 4, 5, 4, 3]

    var mapResult = numbers.map(function (item, index, array) {
        return (item * 2);
    });
    console.log(mapResult); // [2,4,6,8,10,8,6,4,2]

    numbers.forEach(function (item, index, array) {
        // do something here
    });


    /*
    * reduction method --
    * reduce() and reduceRight()
    * */
    var values = [1, 2, 3, 4, 5];
    var sum = values.reduce(function (prev, cur, index, array) {
        return prev + cur;
    });
    console.log(sum); // 15



    /*
    *
    * The date type --
    *
    * */
    var now = new Date();
    var someDate = new Date(Date.parse("May 25, 2004"));
    console.log(someDate); // Tue May 25 2004 00:00:00 GMT+1000 (AEST)
    console.log(typeof someDate); // object

    var someDate1 = new Date("May 25, 2004");
    console.log(someDate1); // Tue May 25 2004 00:00:00 GMT+1000 (AEST)
    console.log(typeof someDate1); // object

    console.log(new Date(Date.UTC(2000, 0))); // Sat Jan 01 2000 11:00:00 GMT+1100 (AEDT)

    console.log(Date.now()); // 1480844818359

    console.log(+new Date()); // 1480844857105

    /*
    * toDateString(), toTimeString(), toLocaleDateString(), toLocaleTimeString()
    *
    * getTime(), getTime(millisecond), getFullYear(), getMonth(), getDate(), getDay(), getHours(), getMinutes(), getSeconds()
    * */
    console.log(someDate.toDateString()); // Tue May 25 2004
    console.log(someDate.toTimeString()); // 00:00:00 GMT+1000 (AEST)

    console.log(someDate.getDay()); // 2
    console.log(someDate.getMonth()); // 4
    console.log(someDate.getFullYear()); // 2004


    /*
    * regexp type --
    * */
//    var expression = /pattern/flags;

    /*
    * g -- indicates global mode, meaning the pattern will be applied to all of the string instead of stopping after the first match is found
    * i -- indicates case-insensitive mode, meaning the case of the pattern and the string are ignore when determining matches.
    * m -- indicates multiline mode, meaning the pattern will continue looking for matches after reaching the end of one line of text.
    * */

    // a regular expression is created using a combination of a pattern and these flags to produce different results

    // match all instances of "at" in string
    var pattern1 = /at/g;

    //match the first instance of "bat" or "cat", regardless of case
    var pattern2 = /[bc]at/i;

    // match all three-character combinations ending with "at", regardless of case
    var pattern3 = /.at/gi;

    // match the first instance of "[bc]at", regardless of case
    var pattern4 = /\[bc\]at/i;

    // match all instances of ".at", regardless of case
    var pattern5 = /\.at/gi;

    var pattern51 = new RegExp("\\.at", "gi");

    /*
    * the primary method of a regexp object is exec(), which is intended for use with capturing groups. this method accepts a single argument, which is the string
    * on which to aply the pattern, and returns an array of information about the first match or null if no match was found.
    * the first item of the returned array is index, which is the location in the string where the pattern was matched.
    * */

    var text = "mom and dad and baby";
    var pattern = /mom( and dad( and baby)?)?/gi;

    var matches = pattern.exec(text);
    console.log(matches.index); // 0
    console.log(matches.input); // mom and dad and baby
    console.log(matches[0]); // mom and dad and baby
    console.log(matches[1]); //  and dad and baby
    console.log(matches[2]); // and baby

    // with the g flag set on the pattern, each call to exec() moves further into the string looking for matches, as in this example
    var text = "cat, bat, sat, fat";
    var pattern6 = /.at/g;

    var matches = pattern6.exec(text);

    console.log(matches.index); // 0
    console.log(matches[0]); // cat

    matches = pattern6.exec(text);
    console.log(matches.index); // 5
    console.log(matches[0]); // bat

    // another method of regular expression is test(), which accept a string argument and return true if the pattern matches the argument and false if it
    // does not.
    var text = "000-00-0000";
    var pattern = /\d{3}-\d{2}-\d{4}/;
    if (pattern.test(text)) {
        console.log("the pattern was matched."); // output the text
    }


    /*
    * function type --
    *
    * function are object, each function is an instance of the Function type that has properties and methods just like any other reference type.
    * because functions are objects, function names are simply points to function objects and are not necessarily tied to the function itself.
    * */

    // function declaration
    function sum(num1, num2) {
        return num1 + num2;
    }

    // function expression
    var sum = function (num1, num2) {
        return num1 + num2;
    };

    var sum = new Function("num1", "num2", "return num1 + num2"); // not recommended

    /*
    * function names are simply pointers to functions, they act like any other variable containing a pointer to an object, this means its possible to have
    * multiple names for a single function
    * */
    function sum(num1, num2) {
        return num1 + num2;
    }
    console.log(sum(10, 10)); // 20

    var anotherSum = sum;
    console.log(anotherSum(10, 10));
    sum = null;
    console.log(anotherSum(10, 10)); // 20

    // also, declaring two functions with the same name always results in the last function overwriting the previous one.

    //here should note that, function declarations are read and available in an execution context before any code is executed, wheres function expressions arenot
    // complete until the execution reaches that line of code.

    /*
    * function are read and added to the execution context before the code begins running through a process called function decalaration hoisting.
    * as the code is being evaluated, the JS engine does a first pass for function declarations and pulls them to the top of the source tree.
    *
    * but function expression has not the func as hoisting.
    * */

    console.log(sum6(10, 10));
    function sum6(num1, num2) {
        return num1 + num2;
    }

    /*
    * functions as values --
    * function names are nothing more than variables, function can be used any place any other value can be used.
    * it means that it not only pass a function into another function as an argument but also to return a function as the result of another function
    * */
    function callFunction(someFunction, someArgument) {
        return someFunction(someArgument);
    }

    function add10(num) {
        return num + 10;
    }
    var result1 = callFunction(add10, 10);
    console.log(result1); // 20

    function getGreeting(name) {
        return "hello, " + name;
    }
    var result2 = callFunction(getGreeting, "rick");
    console.log(result2); // hello, rick

    /*
    * remember that to access a function pointer instead of executing the function, you must leave off the parenthese, so the variable
    * add10, and getGreeting are passed into callFunction() instead of their results being passed in.
    * */

    // returning a function from a function is also possible and can be quite useful.
    function createComparisonFunction(propertyName) {

        return function (obj1, obj2) {
            var val1 = obj1[propertyName];
            var val2 = obj2[propertyName];

            if (val1 < val2) {
                return -1;
            } else if (val1 > val2) {
                return 1;
            } else {
                return 0;
            }
        };
    }

    // the essential is just a function inside of a function, proceded by the return operator.
    var data = [{name: "rick", age: 30}, {name: "leo", age: 40}];
    data.sort(createComparisonFunction("name"));
    console.log(data[0].name); // leo

    data.sort(createComparisonFunction("age"));
    console.log(data[0].name); // rick

    /*
    * function internals --
    * two special objects exist inside a function: arguments and this. the arguments object is an array-like object that contains all of
    * the arguments that were passed into the function.
    * though its primary use is to represent function arguments, the arguments object has a property named callee, which is a pointer to
    * the function that owns the arguments object.
    * */

    function factorial(num) {
        if (num <= 1) {
            return 1;
        } else {
            return num * arguments.callee(num - 1);
        }
    }

    // the other object is called this, which is a reference to the context object that the function is operating on.

    window.color = "red";
    var o = {color: "blue"};
    function sayColor() {
        console.log(this.color);
    }
    sayColor(); // red
    o.sayColor = sayColor;
    o.sayColor(); // blue

    /*
    * function properties and methods --
    * each function has two properties: length and prototype
    * length indicates the number of named arguments that the function expects
    * */

//    function sayName(name) {
//        console.log(name);
//    }
//    function sum(num1, num2) {
//        return num1 + num2;
//    }
    function sayHi() {
        console.log("hi");
    }

//    console.log(sayName.length); // 1
//    console.log(sum.length); // 2
    console.log(sayHi.length); // 0


 /*
 * prototype property is the actual location of all instance methods for reference types, meaning methods such as toString() and valueOf()
 * actually exist on the prototype and are then accessed from the object instances. prototype can not be found using for-in and not
 * enumerable.
 * */

 /*
 * there are two methods: apply() and call(), these methods both call the function with a specific this value, effectively setting the value
 * of the this object inside the function body.
 * */
     function sum10(num1, num2) {
         return num1 + num2;
     }
     function callSum1(num1, num2) {
         return sum10.apply(this, arguments);
     }
     function callSum2(num1, num2) {
         return sum10.apply(this, [num1, num2]);
     }

     console.log(callSum1(10, 10));
     console.log(callSum2(10, 10));

    function callSum3(num1, num2) {
        return sum10.call(this, num1, num2);
    }
    console.log(callSum3(10, 10)); // 20

    window.color = "red";
    var o = {color: "blue"};

    function sayColor() {
        console.log(this.color);
    }
    sayColor(); // red
    sayColor.call(this); // red
    sayColor.call(window); // red
    sayColor.call(o); // blue

    /*
    * the advantage of using call() or apply() to augment the scope is that the object doesnot need to know anything about the method.
    * in the first version of this example, the sayColor() function was placed directly on the object o before it was called.
    * */

    /*
    * primitive wrapper types --
    *
    * String(), Number(), Boolean(),
    * each time a primitive value is read, an object of the corresponding primitive wrapper type is created behind the scene.
    * */

    var s1 = "some text";
    var s2 = s1.substring(2);
    console.log(s2); // me text
    console.log(s1);

    /*
    * create an instance of the String type, call the specified method on the instance and destroy the instance.
    * */

    // we can think as following
    var s1 = new String("some text");
    var s2 = s1.substring(2);
    s1 = null;

    // this behavior allows the primitive string value to act like an object.

    /*
    * the major difference between reference types and primitive wrapper types is the lifetime of the object. when we instantiate
     * a reference type using the new operator, it stays in memory until it goes out of scope, whereas automatically created primitive wrapper object
     * exist for only one line of code before they are destroyed. it means that property and methods cannot be added at runtime.
    * */
    var s1 = "some text"; // the primitive wrapper type
    s1.color = "red";
    console.log(s1.color); // undefined, because of destroyed in line of code

    var s2 = new String("some text");
    s2.color = "blue";
    console.log(s2.color); // blue

    // Object constructor also acts as factory method and is capable of returning an instance of a primitive wrapper based on the type
    // of value passed into the constructor.
    var obj = new Object("some text");
    console.log(obj instanceof String); // true

    // keep in mind that calling a primitive wrapper constructor using new is not the same as calling the casting function of the same name
    var value = "25";
    var number = Number(value);
    console.log(typeof number); // number

    var obj = new Number(value);
    console.log(typeof obj); // object

    // Boolean type --

    var falseObject = new Boolean(false);
    var result = falseObject && true;
    console.log(result); // true

    var falseValue = false;
    result = falseValue && true;
    console.log(result); // false

    /*
    * a Boolean object is created with a value of false, it is the object named falseObject being evaluated, not its value (false),
    * all objects are automatically converted to true in Boolean expressions. so falseObject actually is given a value of true.
    * */
    console.log(typeof falseObject); //object
    console.log(typeof falseValue); // boolean
    console.log(falseObject instanceof Boolean); // true
    console.log(falseValue instanceof Boolean); // false, its a primitive type, not the Object


    /*
    * The number type --
    * it overrides valueOf() , which return the primitive numeric value represented by the object, and toString() return the value in
    * string type
    * */

    var num = 10;
    console.log(num.toString()); // "10"
    console.log(num.toString(2)); // "1010"
    console.log(num.toString(8)); // "12"
    console.log(num.toString(10)); //"10"
    console.log(num.toString(16)); // "a"

    var num = 10;
    console.log(num.toFixed(2)); // "10.00", return a string representation of a number with specified number of decimal points
    console.log(typeof (num.toFixed(2))); // string

    var num = 10.005;
    console.log(num.toFixed(2)); // "10.01", has the rounding nature

    var num = 10;
    console.log(num.toExponential(1)); // 1.0e+1

    var num = 99;
    console.log(num.toPrecision(1)); // 1e+2
    console.log(num.toPrecision(2)); // 99
    console.log(num.toPrecision(3)); // 99.0

    var numberObject = new Number(10);
    var numberValue = 10;
    console.log(typeof numberObject); // object
    console.log(typeof numberValue); // number
    console.log(numberObject instanceof Number); // true
    console.log(numberValue instanceof Number); // false


    /*
    * the String type ---
    *
    * all three of the inherited methods -- valueOf(), toLocaleString(), and toString() return the object's primitive string value
    *
    * each instance of String contains a single property, length.
    * */

    var stringValue = "hello world";
    console.log(stringValue.length); // 11

    console.log(stringValue.charAt(1)); // "e"
    console.log(stringValue.charCodeAt(1)); // "101"
    console.log(stringValue[1]); // "e"

    var stringValue = "hello ";
    var result = stringValue.concat("world");
    console.log(result); // hello world
    console.log(stringValue); // hello

    var result = stringValue.concat("world", "!");
    console.log(result); // hello world!

    // the addition operator (+) is more used than concat
    result = stringValue + "world";
    console.log(result); // hello world

    var stringValue = "hello world";
    console.log(stringValue.slice(3)); // "lo world"
    console.log(stringValue.substring(3)); // "lo world"
    console.log(stringValue.substr(3)); // "lo world"
    console.log(stringValue.slice(3,7));  // "lo w" -- does not include the position of 7
    console.log(stringValue.substring(3,7)); // "lo w"
    console.log(stringValue.substr(3,7)); // "lo worl"

    console.log(stringValue.slice(-3)); // "rid"
    console.log(stringValue.substring(-3)); // "hello world"
    console.log(stringValue.substr(-3)); // "rid"

    console.log(stringValue.slice(3,-4)); // "lo w"
    console.log(stringValue.substring(3,-4)); // "hel"
    console.log(stringValue.substr(3,-4)); // ""

    console.log(stringValue.indexOf("o")); // 4
    console.log(stringValue.lastIndexOf("o")); // 7

    console.log(stringValue.indexOf("o", 6)); // 7
    console.log(stringValue.lastIndexOf("o", 6)); // 4



    // a sample of geting the position of "e" in one sentence.

    var stringValue = "Lorem ipsum dolor sit amet, consectetur adipisicing elit";
    var positions = new Array();
    var pos = stringValue.indexOf("e");

    while (pos > -1) {
        positions.push(pos);
        pos = stringValue.indexOf("e", pos+1);
    }
    console.log(positions); // [3, 24, 32, 35, 52]


    // trim() method -- removes all leading and trailing white space, the then return the result

    var stringValue = "   hello world    ";
    var trimedString = stringValue.trim();
    console.log(stringValue); // "   hello world    "
    console.log(trimedString); // "hello world"


    // string case methods -- toLowerCase(), toUpperCase()
    stringValue = "Hello World";
    console.log(stringValue.toLowerCase()); // hello world
    console.log(stringValue.toUpperCase()); // HELLO WORLD
    console.log(stringValue); // Hello World


    // string pattern-matching method

    var text = "cat, bat, sat, fat";
    var pattern = /.at/;

    // same as pattern.exec(text);
    var matches = text.match(pattern);
    console.log(matches.index);  //0
    console.log(matches[0]);   // "cat"
    console.log(matches.lastIndex); // 0


    // Singleton Built-in object  -- defines a built-in object as "any object supplied by JS", independent of the host environment, which is
    // present at the start of the execution of a JS program.

    // Object, Array, String, Global, Math

    /*
    * Global object as a sort of catchall for properties and methods that donot otherwise have an owning object, all variables and functions
    * defined globally become properties of the Global object.
    * isNaN(), isFinite(), parseInt(), parseFloat(), encodeURI(), encodeURIComponent() methods,
    * decodeURI(), decodeURIComponent()
    * */

    var uri = "http://www.wrox.com/illegal value.htm#start";
    //”http://www.wrox.com/illegal%20value.htm#start”
    console.log(encodeURI(uri));

    //”http%3A%2F%2Fwww.wrox.com%2Fillegal%20value.htm%23start”
    console.log(encodeURIComponent(uri)); // return all nonalphanumeric characters


    // eval() method -- works like an entire JS interpreter and accepts one argument, a string of JS to execute.
    eval("console.log('hello')");  // hello

    // any variables or functions created inside of eval() will not be hoisted, as they are contained within a string when
    // the code is being parsed.they are created only at the time of eval() execution.

    // Window object -- web browsers implement it such that the window is the Global object's delegate.

    // Math Object -- Math.PI, Math.min(), Math.max(),

    console.log(Math.max(3,54,32,28)); // 54
    console.log(Math.min(3,54,32,28)); // 3

    // to find the maximum or the minimum value in an array,
    var values = [1, 2, 3, 4, 5, 6, 7, 8];
    var max = Math.max.apply(Math, values);
    console.log(max); //8

    // Math.ceil(), Math.floor(), Math.round() -- the integer value

    // Math.random() --  to select numbers within a certain integer range,
//    number = Math.floor(Math.random() * total_number_of_choices + first_possible_value);

    // select a number between 1 and 10,
    var num = Math.floor(Math.random() * 10 + 1);

    // select a number between 2 and 10
    var num = Math.floor(Math.random() * 9 + 2 );

//    so we get a function
    function selectFrom(lowerVal, upperVal) {
        var choices = upperVal - lowerVal + 1;
        return Math.floor(Math.random() * choices + lowerVal);
    }

    var num = selectFrom(2, 10);
    console.log(num); // number between 2 and 10, inclusive

    var colors = ["red", "green", "blue", "yellow", "black", "purple", "brown"];
    var color = colors[selectFrom(0, colors.length-1)];
    console.log(color);















</script>
</body>
</html>

































