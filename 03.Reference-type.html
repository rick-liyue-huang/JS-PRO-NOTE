<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title></title>
</head>
<body>
<script>

    /*
    * a reference value is an instance of reference type. in JS, reference type are constructors used to group data and
    * functionality together and are often incorrectly called classes. Reference types are also sometimes called object definitions.
    * they describe the properties and methods that objects should have.
    *
    * objects are considered to be instances of a particular reference type. new objects are created by using the new operator
    * followed by a constructor.
    *
    * a constructor is similar as the function whose purpose is to create a new object.
    * */

    /*
    * object type --
    * there are two ways to explicitly create an instance of Object. The first one is to use the new operator with the Object
    * constructor.
    * */
    var person = new Object();
    person.name = "Leo";
    person.age = 29;

    /*
    * the other one is to use object literal notation, which is a shorthand of form of object definition designed to simplify creating an object with
    * numerous properties. we recommend this method. object literal has become a preferred way of passing a large number of optional arguments to a function
    * */

    var person = {
        name: "rick",
        age: 30
    };

    function displayInfo(args) {
        var output = "";

        if (typeof args.name == "string") {
            output += "name: " + args.name + "\n";
        }

        if (typeof args.age == "number") {
            output += "age: " + args.age + "\n";
        }
        console.log(output);
    }

    displayInfo({
        name: "rick",
        age: 20
    });
    displayInfo({
        name: "leo"
    });

    // dot notation and bracket notation

    console.log(person.name);
    console.log(person["name"]);

    /*
    * we can use bracket notation when the property name contains characters that would be either a syntax error or a keyword
    * */


    /*
    * The Array Type --
    * JS arrays are ordered lists of data, they can hold any type of data in each slot, this means that its possible to create an array that has a string in the first
    * position, a number in the second, and an object in the third, and so on. arrays can be created in two basic ways, the first is to use the Array constructor
    * */

    var colors = new Array();
    var colors = new Array("red", "blue", "green");
    console.log(colors); // [red, blue, green]
    var colors = new Array(3);
    var colors = Array(4);
    var names = Array("rick");

    // the second way to create an array is by using array literal notation.
    var colors = ["green", 'red', 'yellow'];
    var names = [];
    var values = [1,2,];
    var option = [,,,,];

    // the length property is writable and readable
    var colors = [1, 2, 4];
    colors.length = 2;
    console.log(colors[2]); // undefined

    // the length property can also be helpful in adding items to the end of an array.
    colors[colors.length] = "black";
    console.log(colors); // 1 2 black


    /*
    * detecting array
    * */
//    if (value instanceof Array) {
//        // do something on the array
//    }
//
//    if (Array.isArray(value)) {
//        // do something on the array
//    }

    /*
    * conversion method --
    * all objects have toLocaleString(), toString(), valueOf(). toString() and valueOf() methods return the same value when called on an array
    * */
    var colors = ["red", 'blue', 'green'];
    console.log(colors.toString());
    console.log(typeof (colors.toString())); // string
    console.log(colors.valueOf());
    console.log(typeof (colors.valueOf())); // object
    console.log(colors);
    console.log(typeof colors);  // object

    var person1 = {
        toLocaleString: function () {
            return "localeLeo";
        },
        toString: function () {
            return "leo";
        }
    };
    var person2 = {
        toLocaleString: function () {
            return "localeRick";
        },
        toString: function () {
            return "rick";
        }
    };
    var people = [person1, person2];
    console.log(people); // array
    console.log(people.toString());  // leo rick
    console.log(people.toLocaleString()); // localeLeo, localeRick

    var colors = ["red", "yello", "blue"];
    console.log(colors.join("|")); // red|yellow|blue
    console.log(colors.join(".")); // red.yellow.blue

    // if an item in array is null or undefined, it is represented by an empty string in the result of join(), toLocaleString(), toString(), valueOf()

    /*
    * stack method
    * a stack is reference to as last-in-first-out structure, meaning that the most recently added item is the first one removed. the insertion and removal
    * of items in  a stack occur at only one point: the top of the stack.
    *
    * the push() method accepts any number of arguments and adds them to the end of the array, returning the array's new length.
    * the pop() method removes the last item in the array, decrements the array's length, and return that item.
    * */
    var colors = new Array();
    var count = colors.push("red", "green");
    console.log(count);

    count = colors.push("black");
    console.log(count);

    var item = colors.pop();
    console.log(item);
    console.log(colors);
    console.log(colors.length); // red green

    /*
    * queue methods --
    * queue restrict access in a first-in-first-out data structure.
    * shift() method retrieve the first item in the array, which removes the first item in the array and returns it.
    * unshift() method adds any number of items to the front of an array and returns the new array.
    * */

    var colors = new Array();
    var count = colors.push("red", "green");
    console.log(count);

    var count = colors.push("yellow");
    console.log(count);

    var item = colors.shift();
    console.log(item); // red
    console.log(colors.length); // 2

    var colors = new Array();
    var count = colors.unshift("red", "green");
    console.log(count);

    count = colors.unshift("white");
    var item = colors.pop();
    console.log(item); // green


    /*
    * reordering method
    *
    * reverse() and sort()
    *
    *
    * */
    var values = [1,2,3,4,5];
    values.reverse();
    console.log(values); // 5 4 3 2 1

    var values = [0, 1,5,10,15];
    values.sort();
    console.log(values);

    function compare(val1, val2) {
        if (val1 < val2) {
            return -1;
        } else if (val1 > val2) {
            return 1;
        } else {
            return 0;
        }
    }

    var values = [0, 1, 5, 10, 15];
    values.sort(compare);
    console.log(values); // 0 1 5 10 15

    function compare1(val1, val2) {
        if (val1 < val2) {
            return 1;
        } else if (val1 > val2) {
            return -1;
        } else {
            return 0;
        }
    }
    values.sort(compare1);
    console.log(values); // 15 10 5 1 0

    // a much simpler version of the comparison function can be used with numeric types
    function compare2(val1, val2) {
        return val2 - val1;
    }


    /*
    * manipulation method --
    * */

    var colors = ["red", "green", "blue"];
    var colors2 = colors.concat("yellow", ["black", "brown"]);
    console.log(colors); // red green blue
    console.log(colors2); // red green blue yellow black brown


    //slice(arg1, arg2), may accept
    var colors3 = colors2.slice(1);  // ["green", "blue", "yellow", "black", "brown"]
    var colors4 = colors2.slice(1, 4); // green, blue, yellow
    console.log(colors3);
    console.log(colors4);

    // splice(),
    /*
    * deletion -- any number of items can be deleted from the array by specifying just two arguments: the position of the first item to delete and the number of items
    * to delete.
    *
    * insertion -- three arguments, the starting position, the numbers of items to be deleted and the items to insert.
    *
    * replacement -- items can be inserted into a specific position while simultaneously deleting items,
    * */

    var colors = ["red", "green", "blue"];
    var removed = colors.splice(0, 1);
    console.log(colors); // green, blue
    console.log(removed); // red

    removed = colors.splice(1, 0, "yellow", "orange");
    console.log(colors); // green, yellow, orange, blue
    console.log(removed); // []

    removed = colors.splice(1, 1, "red", "purple");
    console.log(colors); // green, red, purple, orange, blue
    console.log(removed); // yellow


    /*
    * Location Method --
    * indexOf() and lastIndexOf() , which accept two arguments: the item to look for and an optional index from which to start looking.
    * indexOf() start from the index 0, and lastIndexOf() start from the last item.
    * */

    var numbers = [1 ,2, 3, 4, 5, 4, 3, 2, 1];

    console.log(numbers.indexOf(4)); // 3
    console.log(numbers.lastIndexOf(4)); // 5

    console.log(numbers.indexOf(4, 4)); // 5
    console.log(numbers.lastIndexOf(4, 4)); // 3

    var person = {name: "rick"};
    var people = [{name: "rick"}];

    var morePeople = [person];
    console.log(people.indexOf(person)); // -1
    console.log(morePeople.indexOf(person)); // 0

    /*
    * iterative method --
    *
    * every() -- runs the given function on every item in the array and returns true if the function returns true for every item.
    *
    * filter() -- runs the given function on every item in the array and returns an array of all items for which the function returns true.
    *
    * forEach() -- runs the given function on every item in the array. this method has no return value.
    *
    * map() -- runs the given function on every item in the array and returns the result of each function call in an array.
    *
    * some() -- runs the given function on every item in the array and returns true if the function returns true for any one item.
    * */

    var numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];

    var everyResult = numbers.every(function (item, index, array) {
        return (item > 2);
    });
    console.log(everyResult); // false

    var someResult = numbers.some(function (item, index, array) {
        return (item > 2);
    });
    console.log(someResult); // true

    var filterResult = numbers.filter(function (item, index, array) {
        return (item > 2);
    });
    console.log(filterResult); // [3, 4, 5, 4, 3]

    var mapResult = numbers.map(function (item, index, array) {
        return (item * 2);
    });
    console.log(mapResult); // [2,4,6,8,10,8,6,4,2]

    numbers.forEach(function (item, index, array) {
        // do something here
    });


    /*
    * reduction method --
    * reduce() and reduceRight()
    * */
    var values = [1, 2, 3, 4, 5];
    var sum = values.reduce(function (prev, cur, index, array) {
        return prev + cur;
    });
    console.log(sum); // 15



    /*
    *
    * The date type --
    *
    * */
    var now = new Date();
    var someDate = new Date(Date.parse("May 25, 2004"));
    console.log(someDate); // Tue May 25 2004 00:00:00 GMT+1000 (AEST)
    console.log(typeof someDate); // object

    var someDate1 = new Date("May 25, 2004");
    console.log(someDate1); // Tue May 25 2004 00:00:00 GMT+1000 (AEST)
    console.log(typeof someDate1); // object

    console.log(new Date(Date.UTC(2000, 0))); // Sat Jan 01 2000 11:00:00 GMT+1100 (AEDT)

    console.log(Date.now()); // 1480844818359

    console.log(+new Date()); // 1480844857105

    /*
    * toDateString(), toTimeString(), toLocaleDateString(), toLocaleTimeString()
    *
    * getTime(), getTime(millisecond), getFullYear(), getMonth(), getDate(), getDay(), getHours(), getMinutes(), getSeconds()
    * */
    console.log(someDate.toDateString()); // Tue May 25 2004
    console.log(someDate.toTimeString()); // 00:00:00 GMT+1000 (AEST)

    console.log(someDate.getDay()); // 2
    console.log(someDate.getMonth()); // 4
    console.log(someDate.getFullYear()); // 2004


    /*
    * regexp type --
    * */
//    var expression = /pattern/flags;

    /*
    * g -- indicates global mode, meaning the pattern will be applied to all of the string instead of stopping after the first match is found
    * i -- indicates case-insensitive mode, meaning the case of the pattern and the string are ignore when determining matches.
    * m -- indicates multiline mode, meaning the pattern will continue looking for matches after reaching the end of one line of text.
    * */

    // a regular expression is created using a combination of a pattern and these flags to produce different results

    // match all instances of "at" in string
    var pattern1 = /at/g;

    //match the first instance of "bat" or "cat", regardless of case
    var pattern2 = /[bc]at/i;

    // match all three-character combinations ending with "at", regardless of case
    var pattern3 = /.at/gi;

    // match the first instance of "[bc]at", regardless of case
    var pattern4 = /\[bc\]at/i;

    // match all instances of ".at", regardless of case
    var pattern5 = /\.at/gi;

    var pattern51 = new RegExp("\\.at", "gi");

    /*
    * the primary method of a regexp object is exec(), which is intended for use with capturing groups. this method accepts a single argument, which is the string
    * on which to aply the pattern, and returns an array of information about the first match or null if no match was found.
    * the first item of the returned array is index, which is the location in the string where the pattern was matched.
    * */

    var text = "mom and dad and baby";
    var pattern = /mom( and dad( and baby)?)?/gi;

    var matches = pattern.exec(text);
    console.log(matches.index); // 0
    console.log(matches.input); // mom and dad and baby
    console.log(matches[0]); // mom and dad and baby
    console.log(matches[1]); //  and dad and baby
    console.log(matches[2]); // and baby

    // with the g flag set on the pattern, each call to exec() moves further into the string looking for matches, as in this example
    var text = "cat, bat, sat, fat";
    var pattern6 = /.at/g;

    var matches = pattern6.exec(text);

    console.log(matches.index); // 0
    console.log(matches[0]); // cat

    matches = pattern6.exec(text);
    console.log(matches.index); // 5
    console.log(matches[0]); // bat

    // another method of regular expression is test(), which accept a string argument and return true if the pattern matches the argument and false if it
    // does not.
    var text = "000-00-0000";
    var pattern = /\d{3}-\d{2}-\d{4}/;
    if (pattern.test(text)) {
        console.log("the pattern was matched."); // output the text
    }


    /*
    * function type --
    *
    * function are object, each function is an instance of the Function type that has properties and methods just like any other reference type.
    * because functions are objects, function names are simply points to function objects and are not necessarily tied to the function itself.
    * */

    // function declaration
    function sum(num1, num2) {
        return num1 + num2;
    }

    // function expression
    var sum = function (num1, num2) {
        return num1 + num2;
    };

    var sum = new Function("num1", "num2", "return num1 + num2"); // not recommended

    /*
    * function names are simply pointers to functions, they act like any other variable containing a pointer to an object, this means its possible to have
    * multiple names for a single function
    * */
    function sum(num1, num2) {
        return num1 + num2;
    }
    console.log(sum(10, 10)); // 20

    var anotherSum = sum;
    console.log(anotherSum(10, 10));
    sum = null;
    console.log(anotherSum(10, 10)); // 20

    // also, declaring two functions with the same name always results in the last function overwriting the previous one.

    //here should note that, function declarations are read and available in an execution context before any code is executed, wheres function expressions arenot
    // complete until the execution reaches that line of code.

    /*
    * function are read and added to the execution context before the code begins running through a process called function decalaration hoisting.
    * as the code is being evaluated, the JS engine does a first pass for function declarations and pulls them to the top of the source tree.
    *
    * but function expression has not the func as hoisting.
    * */

    console.log(sum6(10, 10));
    function sum6(num1, num2) {
        return num1 + num2;
    }

    /*
    * functions as values --
    * function names are nothing more than variables, function can be used any place any other value can be used.
    * it means that it not only pass a function into another function as an argument but also to return a function as the result of another function
    * */
    function callFunction(someFunction, someArgument) {
        return someFunction(someArgument);
    }

    function add10(num) {
        return num + 10;
    }
    var result1 = callFunction(add10, 10);
    console.log(result1); // 20

    function getGreeting(name) {
        return "hello, " + name;
    }
    var result2 = callFunction(getGreeting, "rick");
    console.log(result2); // hello, rick

    /*
    * remember that to access a function pointer instead of executing the function, you must leave off the parenthese, so the variable
    * add10, and getGreeting are passed into callFunction() instead of their results being passed in.
    * */

    // returning a function from a function is also possible and can be quite useful.
    function createComparisonFunction(propertyName) {

        return function (obj1, obj2) {
            var val1 = obj1[propertyName];
            var val2 = obj2[propertyName];

            if (val1 < val2) {
                return -1;
            } else if (val1 > val2) {
                return 1;
            } else {
                return 0;
            }
        };
    }

    // the essential is just a function inside of a function, proceded by the return operator.
    var data = [{name: "rick", age: 30}, {name: "leo", age: 40}];
    data.sort(createComparisonFunction("name"));
    console.log(data[0].name); // leo

    data.sort(createComparisonFunction("age"));
    console.log(data[0].name); // rick

    /*
    * function internals --
    * two special objects exist inside a function: arguments and this. the arguments object is an array-like object that contains all of
    * the arguments that were passed into the function.
    * though its primary use is to represent function arguments, the arguments object has a property named callee, which is a pointer to
    * the function that owns the arguments object.
    * */

    function factorial(num) {
        if (num <= 1) {
            return 1;
        } else {
            return num * arguments.callee(num - 1);
        }
    }

    // the other object is called this, which is a reference to the context object that the function is operating on.

    window.color = "red";
    var o = {color: "blue"};
    function sayColor() {
        console.log(this.color);
    }
    sayColor(); // red
    o.sayColor = sayColor;
    o.sayColor(); // blue

    /*
    * function properties and methods --
    * each function has two properties: length and prototype
    * length indicates the number of named arguments that the function expects
    * */

//    function sayName(name) {
//        console.log(name);
//    }
//    function sum(num1, num2) {
//        return num1 + num2;
//    }
    function sayHi() {
        console.log("hi");
    }

//    console.log(sayName.length); // 1
//    console.log(sum.length); // 2
    console.log(sayHi.length); // 0




</script>
</body>
</html>

































